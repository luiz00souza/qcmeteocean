import streamlit as st
import plotly.graph_objects as go
import numpy as np
import sys
import streamlit as st
import pandas as pd
import plotly.express as px
import datetime
import random
import matplotlib.pyplot as plt
import plotly as plt
from streamlit_option_menu import option_menu


# sys.path.append(r'G:\Drives compartilhados\DHE_REPASSE\2024\ID00_PD_MITR-QCMO\01_Scripts\20241206_Version_008')
from Acesso_Dados_servidor_FTP import *
from QC_OPERACIONAL_UMISAN import *

# Definindo um dicion√°rio com login, senha e permiss√µes
usuarios = {
    "admin": {"senha": "admin123", "permissao": "admin","projetos":"ID0012025"},
    "usuario1": {"senha": "usuario123", "permissao": "usuario","projetos":"ID0212025"},
    "usuario2": {"senha": "senha123", "permissao": "usuario","projetos":"ID0232025"},
}
st.set_page_config(
    page_title="Monitoramento Meteoceanogr√°fico",
    page_icon="üåä",
    layout="wide"
)
def autenticar_usuario(usuario, senha):
    """Verifica se o usu√°rio e a senha s√£o v√°lidos e retorna a permiss√£o do usu√°rio."""
    if usuario in usuarios and usuarios[usuario]["senha"] == senha:
        return usuarios[usuario]["permissao"]
    return None

# Fun√ß√£o para exibir o conte√∫do do administrador
def exibir_conteudo_admin():
    """Exibe conte√∫do exclusivo para administradores."""
    st.subheader("Voc√™ √© um Administrador!")
    st.write("Exemplo de funcionalidades de administrador.")
    exibir_filtro()

# Fun√ß√£o para exibir o conte√∫do do usu√°rio
def exibir_conteudo_usuario():
    """Exibe conte√∫do para usu√°rios comuns."""
    st.subheader("Voc√™ √© um Usu√°rio Comum!")
    st.write("Voc√™ tem acesso a funcionalidades b√°sicas.")
    exibir_filtro()



def criar_titulo_e_descricao():
    """Exibe o t√≠tulo e a descri√ß√£o da p√°gina inicial."""
    st.title("üåä Monitoramento Meteoceanogr√°fico em Tempo Real")
    st.markdown(
        "Bem-vindo ao painel de monitoramento em tempo real. Explore dados meteorol√≥gicos e oceanogr√°ficos para uma melhor compreens√£o das condi√ß√µes ambientais."
    )

def exibir_mapa_interativo():
    """Cria um mapa interativo com os sensores e suas informa√ß√µes."""
    st.subheader("üìç Localiza√ß√£o das Esta√ß√µes")
    data = {
        "Nome": ["Esta√ß√£o 1", "Esta√ß√£o 2", "Esta√ß√£o 3"],
        "Latitude": [-25.0, -24.5, -24.8],
        "Longitude": [-48.0, -47.8, -47.5],
        "Velocidade do Vento (m/s)": [random.uniform(2, 10) for _ in range(3)],
        "Dire√ß√£o do Vento": ["NE", "S", "W"],
    }
    df = pd.DataFrame(data)
    fig = px.scatter_mapbox(
        df,
        lat="Latitude",
        lon="Longitude",
        hover_name="Nome",
        hover_data=["Velocidade do Vento (m/s)", "Dire√ß√£o do Vento"],
        color="Velocidade do Vento (m/s)",
        color_continuous_scale="Viridis",
        zoom=6,
        height=400,
    )
    fig.update_layout(mapbox_style="carto-positron")
    st.plotly_chart(fig, use_container_width=True)

def exibir_painel_destaques():
    """Exibe os destaques das condi√ß√µes atuais."""
    st.subheader("üìä Condi√ß√µes Atuais")
    cols = st.columns(4)
    cols[0].metric("üå¨Ô∏è Velocidade do Vento", f"{random.uniform(2, 10):.2f} m/s")
    cols[1].metric("üß≠ Dire√ß√£o do Vento", "NE")
    cols[2].metric("üå°Ô∏è Temperatura do Ar", f"{random.uniform(20, 30):.2f} ¬∞C")
    cols[3].metric("üåä Altura de Ondas", f"{random.uniform(1, 3):.2f} m")

def criar_menu():
    """Cria uma faixa de navega√ß√£o no topo."""
    menu = st.radio(
        "",
        options=["In√≠cio", "Sobre", "Cases", "Servi√ßos", "Produtos", "Contato", "Login"],
        horizontal=True,
        label_visibility="collapsed",
    )
    return menu

def exibir_inicio():
    """P√°gina inicial com informa√ß√µes gerais."""
    st.title("üåä Bem-vindo ao Sistema de Monitoramento Meteoceanogr√°fico")
    st.markdown(
        "Explore informa√ß√µes meteoceanogr√°ficas em tempo real para suporte a decis√µes estrat√©gicas. "
        "Este sistema oferece monitoramento detalhado de condi√ß√µes ambientais."
    )
    # exibir_mapa_interativo()
    # exibir_painel_destaques()

def exibir_sobre():
    """P√°gina sobre a empresa ou o sistema."""
    st.title("Sobre N√≥s")
    st.markdown(
        """
        Somos l√≠deres em monitoramento meteoceanogr√°fico, fornecendo solu√ß√µes inovadoras para a coleta e an√°lise de dados ambientais.
        Nosso objetivo √© capacitar nossos clientes com informa√ß√µes precisas e em tempo real para suportar decis√µes cr√≠ticas.
        """
    )
    st.image("https://via.placeholder.com/800x400", caption="Nossa miss√£o √© transformar dados em solu√ß√µes.")

def exibir_cases():
    """P√°gina de estudos de caso."""
    st.title("Nossos Cases de Sucesso")
    st.markdown(
        """
        Descubra como nossas solu√ß√µes ajudaram empresas a superar desafios e otimizar opera√ß√µes:
        - **Case 1**: Redu√ß√£o de custos operacionais em 20% com monitoramento de mar√©s.
        - **Case 2**: Previs√£o precisa de condi√ß√µes mar√≠timas para transporte seguro.
        """
    )
    st.image("https://via.placeholder.com/800x400", caption="Impacto positivo com nossas solu√ß√µes.")

def exibir_servicos():
    """P√°gina de servi√ßos oferecidos."""
    st.title("Nossos Servi√ßos")
    st.markdown(
        """
        Oferecemos uma ampla gama de servi√ßos para atender √†s suas necessidades:
        - **Monitoramento em Tempo Real**
        - **An√°lise de Dados Hist√≥ricos**
        - **Integra√ß√£o com APIs Personalizadas**
        - **Consultoria T√©cnica**
        """
    )
    st.image("https://via.placeholder.com/800x400", caption="Solu√ß√µes sob medida para cada cliente.")

def exibir_produtos():
    """P√°gina de produtos."""
    st.title("Nossos Produtos")
    st.markdown(
        """
        Explore nossos produtos inovadores:
        - **Sensores Avan√ßados**: Monitoramento preciso de condi√ß√µes ambientais.
        - **Plataforma Digital**: Visualiza√ß√£o e an√°lise de dados em tempo real.
        - **Alertas Inteligentes**: Notifica√ß√µes autom√°ticas para condi√ß√µes cr√≠ticas.
        """
    )
    st.image("https://via.placeholder.com/800x400", caption="Tecnologia de ponta ao seu alcance.")

def exibir_contato():
    """P√°gina de contato."""
    st.title("Entre em Contato")
    st.markdown(
        """
        Quer saber mais? Estamos aqui para ajudar:
        - üìß **E-mail**: contato@empresa.com
        - üìû **Telefone**: (11) 1234-5678
        - üåê **Site**: [www.empresa.com](http://www.empresa.com)
        """
    )
    with st.form("form_contato"):
        nome = st.text_input("Seu Nome")
        email = st.text_input("Seu E-mail")
        mensagem = st.text_area("Sua Mensagem")
        enviado = st.form_submit_button("Enviar")
        if enviado:
            st.success("Mensagem enviada com sucesso!")

def exibir_login():
    """P√°gina de login."""

    # Chamada da fun√ß√£o principal
    if __name__ == "__main__":
        main()

def main():
    criar_titulo_e_descricao()

    # exibir_graficos_resumidos()
    # exibir_navegacao()
    
    
    # Verificar se o usu√°rio j√° est√° autenticado (caso contr√°rio, pede login)
    if 'usuario' not in st.session_state:
        if not login():  # Se o login falhar
            return

    # Exibe a navega√ß√£o ap√≥s o login
    # exibir_painel_destaques()

    exibir_mapa_interativo()
    exibir_navegacao()

# Fun√ß√£o para autentica√ß√£o

# Fun√ß√£o para exibir os filtros
def exibir_filtro():
    """Exibe filtros interativos para o usu√°rio"""
    st.sidebar.subheader("Filtros de Dados")

    filtro = st.sidebar.selectbox(
        "Escolha uma Esta√ß√£o:",
        ["Esta√ß√£o 1", "Esta√ß√£o 2", "Esta√ß√£o 3"]
    )

    st.sidebar.write(f"Voc√™ escolheu: {filtro}")

# Fun√ß√£o para exibir uma tabela de exemplo


# Fun√ß√£o para exibir texto adicional
def exibir_texto_adicional():
    """Exibe texto explicativo adicional"""
    st.write("Aqui voc√™ pode adicionar mais informa√ß√µes ou instru√ß√µes sobre o uso da aplica√ß√£o.")
    st.write("Por exemplo, voc√™ pode explicar como os filtros funcionam ou dar dicas sobre a utiliza√ß√£o do sistema.")

# Fun√ß√£o para o login
def login():
    """Tela de login onde o usu√°rio insere suas credenciais."""
    st.title("Acesso ao Sistema")
    usuario = st.text_input("Usu√°rio:")
    senha = st.text_input("Senha:", type="password")

    if st.button("Entrar"):
        permissao = autenticar_usuario(usuario, senha)
        
        if permissao:
            st.session_state.usuario = usuario  # Armazenar o usu√°rio na sess√£o
            st.session_state.permissao = permissao  # Armazenar a permiss√£o do usu√°rio
            st.success(f"Bem-vindo, {usuario}!")
            return True  # Login bem-sucedido
        else:
            st.error("Usu√°rio ou senha incorretos. Tente novamente.")
            return False  # Login falhou
    return False  # Nenhuma a√ß√£o de login foi feita

# Fun√ß√£o para exibir as abas de navega√ß√£o
def exibir_navegacao():
    """Exibe bot√µes de navega√ß√£o para outras funcionalidades."""

    # Abas no topo da p√°gina
    abas = ["Mar√©", "Meteorologia", "Correntes", "Ondas", "Ondas N√£o Direcionais"]
    aba_selecionada = st.selectbox("Escolha uma se√ß√£o:", abas)

    if aba_selecionada == "Mar√©":
        exibir_mare()
    elif aba_selecionada == "Meteorologia":
        exibir_meteorologia()
    elif aba_selecionada == "Correntes":
        exibir_correntes()
    elif aba_selecionada == "Ondas":
        exibir_ondas()
    elif aba_selecionada == "Ondas N√£o Direcionais":
        exibir_ondas_nao_direcionais()

    # Exibe conte√∫do do usu√°rio ou admin
    if st.session_state.permissao == "admin":
        exibir_conteudo_admin()
    else:
        exibir_conteudo_usuario()
    st.subheader("üåê Explore Mais")
    st.button("üîç Hist√≥rico de Dados")
    # st.button("üìÖ Previs√µes")
    st.button("‚öôÔ∏è Configurar Alertas")
# Fun√ß√µes para as abas
def exibir_mare():
    """Exibe conte√∫do da aba Mar√©"""
    st.subheader("Informa√ß√µes sobre Mar√©")
    opcao = st.radio("Escolha a op√ß√£o de visualiza√ß√£o", ["Gr√°fico", "Tabela"])
    if opcao == "Gr√°fico":
        # exibir_grafico(df_mare)
        exibir_grafico_mare(df_mare)
        # exibir_grafico(df_mare)

    elif opcao == "Tabela":
        exibir_tabela(df_mare)
def exibir_meteorologia():
    """Exibe conte√∫do da aba Meteorologia"""
    st.subheader("Informa√ß√µes Meteorol√≥gicas")
    opcao = st.radio("Escolha a op√ß√£o de visualiza√ß√£o", ["Gr√°fico", "Tabela"])
    if opcao == "Gr√°fico":
        exibir_grafico_velocidade_vento(df_meteorologia)

        exibir_grafico(df_meteorologia)
    elif opcao == "Tabela":
        exibir_tabela(df_meteorologia)
        
def exibir_correntes():
    """Exibe conte√∫do da aba Correntes"""
    st.subheader("Informa√ß√µes sobre Correntes")
    opcao = st.radio("Escolha a op√ß√£o de visualiza√ß√£o", ["Gr√°fico", "Tabela"])
    if opcao == "Gr√°fico":
        exibir_grafico(df_correntes)
    elif opcao == "Tabela":
        exibir_tabela(df_correntes)
def exibir_ondas():
    """Exibe conte√∫do da aba Ondas"""
    st.subheader("Informa√ß√µes sobre Ondas")
    opcao = st.radio("Escolha a op√ß√£o de visualiza√ß√£o", ["Gr√°fico", "Tabela"])
    if opcao == "Gr√°fico":
        exibir_grafico(df_ondas)
    elif opcao == "Tabela":
        exibir_tabela(df_ondas)    
        
def exibir_ondas_nao_direcionais():
    """Exibe as op√ß√µes de gr√°fico ou tabela na aba Ondas N√£o Direcionais"""
    st.subheader("Informa√ß√µes sobre Ondas N√£o Direcionais")
    opcao = st.radio("Escolha a op√ß√£o de visualiza√ß√£o", ["Gr√°fico", "Tabela"])
    if opcao == "Gr√°fico":
        exibir_grafico(df_ondas_nao_direcionais)
    elif opcao == "Tabela":
        exibir_tabela(df_ondas_nao_direcionais)

# Simulando a fun√ß√£o para importar dados (substitua pela fun√ß√£o real)
def importar_dados_mare():
    
    # Definir o per√≠odo de tempo
    timestamps = pd.date_range(start="2024-01-01", periods=100, freq="H")
    
    # Gerar uma varia√ß√£o realista de mar√© com base em ciclos (seno e cosseno)
    # A mar√© observada pode ter varia√ß√µes com base no ciclo lunar (aproximadamente 28 dias)
    mar√©_observada = 1.5 * np.sin(np.linspace(0, 2 * np.pi * (len(timestamps) / 24), len(timestamps))) + 2

    # A mar√© prevista pode ser um valor similar, mas com um padr√£o diferente ou mais suave
    mar√©_prevista = 1.2 * np.sin(np.linspace(0, 2 * np.pi * (len(timestamps) / 24), len(timestamps))) + 2.1

    # Mar√© com filtro fraco - aplica√ß√£o de suaviza√ß√£o com menor intensidade
    mar√©_filtro_fraco = mar√©_observada + np.random.normal(0, 0.2, len(timestamps))  # Suaviza√ß√£o leve

    # Mar√© com filtro m√©dio - mais suavizado com um valor mais constante
    mar√©_filtro_medio = mar√©_observada + np.random.normal(0, 0.1, len(timestamps))  # Suaviza√ß√£o m√©dia

    # Simula√ß√£o de Tide_level (n√≠vel da mar√©)
    Tide_level = mar√©_observada + np.random.normal(0, 0.3, len(timestamps))

    # Criando o DataFrame
    data = pd.DataFrame({
        'GMT-03:00': timestamps,
        "Tide_level": Tide_level,
        "mar√©_observada": mar√©_observada,
        "mar√©_prevista": mar√©_prevista,
        "mar√©_filtro_fraco": mar√©_filtro_fraco,
        "mar√©_filtro_medio": mar√©_filtro_medio,
        
        "Flag_Tide_level": [0 if i % 5 != 0 else 4 for i in range(100)],  # Flag: 0 v√°lido, 4 inv√°lido
        "Flag_mar√©_observada": [0 if i % 5 != 0 else 4 for i in range(100)],  # Flag: 0 v√°lido, 4 inv√°lido
        "Flag_mar√©_prevista": [0 if i % 5 != 0 else 4 for i in range(100)],  # Flag: 0 v√°lido, 4 inv√°lido
        "Flag_filtro_fraco": [0 if i % 5 != 0 else 4 for i in range(100)] , # Flag: 0 v√°lido, 4 inv√°lido
        "Flag_filtro_medio": [0 if i % 5 != 0 else 4 for i in range(100)]  # Flag: 0 v√°lido, 4 inv√°lido
        })
    return pd.DataFrame(data)

def importar_dados_onda_nao_direcional():
    data =  {
        'GMT-03:00': pd.date_range(start="2024-01-01", periods=100, freq="H"),
        "Tide_level": [1.0 + 0.5 * (i % 12) for i in range(100)],  # Simula varia√ß√£o de mar√©
        "Flag_Tide_level": [0 if i % 5 != 0 else 4 for i in range(100)],  # Flag para Tide_level
        "Wave_height": [0.8 + 0.2 * (i % 10) for i in range(100)],  # Altura de onda
        "Flag_Wave_height": [0 if i % 7 != 0 else 4 for i in range(100)],  # Flag para Wave_height
        "Wave_period": [5 + (i % 6) for i in range(100)],  # Per√≠odo de onda
        "Flag_Wave_period": [0 if i % 6 != 0 else 4 for i in range(100)]  # Flag para Wave_period
    }
    return pd.DataFrame(data)

def importar_dados_ondas():
    data = {
    'GMT-03:00': pd.date_range(start="2024-01-01", periods=100, freq="H"),
    "Tide_level": [i * 0.1 for i in range(100)],
    "Flag_Tide_level": [0 if i % 5 != 0 else 4 for i in range(100)],  # Flag para Tide_level
    "Wave_height_sea": [1.2 + 0.1 * i for i in range(100)],
    "Flag_Wave_height_sea": [0 if i % 7 != 0 else 4 for i in range(100)],  # Flag para Wave_height_sea
    "Wave_height_swell": [0.5 + 0.05 * i for i in range(100)],
    "Flag_Wave_height_swell": [0 if i % 10 != 0 else 4 for i in range(100)],  # Flag para Wave_height_swell
    "Wave_period_sea": [10 + i % 5 for i in range(100)],
    "Flag_Wave_period_sea": [0 if i % 6 != 0 else 4 for i in range(100)],  # Flag para Wave_period_sea
    "Wave_period_swell": [12 + (i % 3) for i in range(100)],
    "Flag_Wave_period_swell": [0 if i % 8 != 0 else 4 for i in range(100)],  # Flag para Wave_period_swell
    }
    return pd.DataFrame(data)

def importar_dados_correntes():
    return pd.DataFrame({
        'GMT-03:00': pd.date_range(start="2024-01-01", periods=100, freq="H"),
        "Current_speed": [0.5 + 0.05 * i for i in range(100)],
        "Flag_Current_speed": [0 if i % 3 != 0 else 4 for i in range(100)],  # Flag para Current_speed
        "Current_direction": [i % 360 for i in range(100)],
        "Flag_Current_direction": [0 if i % 4 != 0 else 4 for i in range(100)],  # Flag para Current_direction
        "Heading": [0.5 + 0.05 * i for i in range(100)],
        "Pitch": [0.5 + 0.05 * i for i in range(100)],
        "Roll": [0.5 + 0.05 * i for i in range(100)],
        "Pressure(dbar)": [0.5 + 0.05 * i for i in range(100)],
        "Temperature(C)": [0.5 + 0.05 * i for i in range(100)],
        "Flag_Heading": [0 if i % 4 != 0 else 4 for i in range(100)],
        "Flag_Pitch": [0 if i % 4 != 0 else 4 for i in range(100)],
        "Flag_Roll": [0 if i % 4 != 0 else 4 for i in range(100)],
        "Flag_Pressure(dbar)": [0 if i % 4 != 0 else 4 for i in range(100)],
        "Flag_Temperature(C)": [0 if i % 4 != 0 else 4 for i in range(100)]
    })

def importar_dados_meteorologia():
    return pd.DataFrame({
        'GMT-03:00': pd.date_range(start="2024-01-01", periods=100, freq="H"),
        "Wind_speed": [2 + 0.1 * i for i in range(100)],
        "Gust_speed": [3 + 0.1 * i for i in range(100)],
        "Flag_Gust_speed":  [0 if i % 2 != 0 else 4 for i in range(100)],
        "Flag_Wind_speed": [0 if i % 3 != 0 else 4 for i in range(100)],  # Flag para Wind_speed
        "Wind Direction(*)": [i % 360 for i in range(100)],
        "Flag_Wind Direction(*)": [0 if i % 4 != 0 else 4 for i in range(100)],  # Flag para Wind_direction
        "Temperature(*C)": [25 + 0.05 * i for i in range(100)],
        "Flag_Temperature(*C)": [0 if i % 5 != 0 else 4 for i in range(100)],  # Flag para Temperature
        'Pressure(hPa)': [1015 - (i % 10) for i in range(100)],
        'Flag_Pressure(hPa)': [0 if i % 6 != 0 else 4 for i in range(100)],  # Flag para Pressure
        "Rain": [0.5 * (i % 3) for i in range(100)],  # Chuva simulada
        "Flag_Rain": [0 if i % 2 != 0 else 4 for i in range(100)],  # Flag para Rainfall
        "RH": [50 + (i % 50) for i in range(100)],  # Umidade Relativa simulada
        "Flag_RH": [0 if i % 3 != 0 else 4 for i in range(100)],  # Flag para RH
        'Dew_Point':[50 + (i % 50) for i in range(100)],
        "Flag_Dew_Point": [0 if i % 3 != 0 else 4 for i in range(100)],  # Flag para RH


        
    })
def grau_para_pontos_cardinais(graus):
    direcoes = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW']
    index = int((graus + 22.5) // 45) % 8  # Para garantir que o valor esteja entre 0 e 7
    return direcoes[index]

# Carregar dados de Ondas N√£o Direcionais
df_mare = importar_dados_mare()
df_ondas=importar_dados_ondas()
df_correntes=importar_dados_correntes()
# df_meteorologia=importar_dados_meteorologia()
df_ondas_nao_direcionais=importar_dados_onda_nao_direcional()


# parametro_para_teste = 'ONDAS' # 'CORRENTES','METEOROLOGIA','MARE','ONDAS'
df_ondas=importar_e_aplicar_QC('ONDAS')
# df_mare=importar_e_aplicar_QC('MARE')
df_correntes=importar_e_aplicar_QC('CORRENTES')
df_meteorologia=importar_e_aplicar_QC('METEOROLOGIA')


# Fun√ß√£o para exibir gr√°fico


# Fun√ß√£o para exibir gr√°ficos de forma iterativa
def exibir_grafico(df):
    st.subheader("Gr√°ficos Din√¢micos - Iterando sobre Colunas")
    
    # Lista de colunas para gr√°ficos (excluindo 'GMT-03:00' e colunas que come√ßam com 'Flag')
    colunas_para_graficos = [col for col in df.columns if col != 'GMT-03:00' and not col.startswith('Flag')]
    
    # Inicializar estado para rastrear o gr√°fico atual
    if "grafico_atual" not in st.session_state:
        st.session_state.grafico_atual = 0
    
    # Gerar o gr√°fico com base na coluna atual
    def gerar_grafico(coluna):
        # Configura√ß√£o de cores para as flags
        cores_legenda = {4: 'red', 0: 'blue'}
        fig = go.Figure()

        # Adicionar a linha principal
        fig.add_trace(go.Scatter(x=df['GMT-03:00'], y=df[coluna], mode='lines',
                                 name=coluna, line=dict(color='blue'), showlegend=False))

        # Adicionar pontos coloridos com base nos valores de flag
        for flag_value, color in cores_legenda.items():
            mask = df[f'Flag_{coluna}'] == flag_value
            fig.add_trace(go.Scatter(x=df['GMT-03:00'][mask], y=df[coluna][mask], mode='markers',
                                     name=f'Flag {flag_value}', 
                                     marker=dict(color=color, size=8), visible='legendonly'))

        # Configurar layout do gr√°fico
        fig.update_layout(
            title=f"S√©rie Temporal de {coluna}",
            yaxis_title=coluna,
            legend_title="Flag",
            showlegend=True,
            xaxis=dict(
                rangeslider=dict(visible=False),
                type='date'
            )
        )
        return fig

    # Obter a coluna atual com base no √≠ndice
    coluna_atual = colunas_para_graficos[st.session_state.grafico_atual]
    fig = gerar_grafico(coluna_atual)
    
    # Exibir o gr√°fico no Streamlit
    st.plotly_chart(fig, use_container_width=True)

    # Navega√ß√£o: Anterior e Pr√≥ximo
    col1, col2 = st.columns([1, 1])
    with col1:
        if st.button("Anterior"):
            if st.session_state.grafico_atual > 0:
                st.session_state.grafico_atual -= 1
            else:
                st.warning("Voc√™ j√° est√° no primeiro gr√°fico!")

    with col2:
        if st.button("Pr√≥ximo"):
            if st.session_state.grafico_atual < len(colunas_para_graficos) - 1:
                st.session_state.grafico_atual += 1
            else:
                st.warning("Voc√™ j√° est√° no √∫ltimo gr√°fico!")


def exibir_grafico_mare(df):
    st.subheader("Gr√°ficos de Mar√© - Observada, Filtro e Prevista")
    cores_legenda = {4: 'red', 0: 'blue'}

    # Verifique se as colunas necess√°rias est√£o no DataFrame
    if 'mar√©_observada' not in df.columns or 'mar√©_prevista' not in df.columns:
        st.error("O DataFrame precisa conter as colunas 'mar√©_observada' e 'mar√©_prevista'.")
        return

    # Adicionar linhas para cada tipo de mar√©
    fig = go.Figure()
    colunas_para_graficos = [col for col in df.columns if col == "mar√©_observada" and not col.startswith('Flag')]
    for coluna in colunas_para_graficos:
        
        # Linha da mar√© observada (linha cont√≠nua)
        fig.add_trace(go.Scatter(x=df['GMT-03:00'], y=df['mar√©_observada'], mode='lines', 
                                 name='Mar√© Observada', line=dict(color='blue')))
        for flag_value, color in cores_legenda.items():
            mask = df[f'Flag_{coluna}'] == flag_value
            fig.add_trace(go.Scatter(x=df['GMT-03:00'][mask], y=df[coluna][mask], mode='markers',
                                     name=f'Flag {flag_value}', 
                                     marker=dict(color=color, size=8)))

    # Linha da mar√© com filtro fraco (linha tracejada)
    fig.add_trace(go.Scatter(x=df['GMT-03:00'], y=df['mar√©_filtro_fraco'], mode='lines', 
                             name='Mar√© com Filtro Fraco', line=dict(color='green'),visible='legendonly'))

    # Linha da mar√© com filtro m√©dio (linha pontilhada)
    fig.add_trace(go.Scatter(x=df['GMT-03:00'], y=df['mar√©_filtro_medio'], mode='lines', 
                             name='Mar√© com Filtro M√©dio', line=dict(color='orange'),visible='legendonly'))

    # Linha da mar√© prevista (linha s√≥lida e cor distinta)
    fig.add_trace(go.Scatter(x=df['GMT-03:00'], y=df['mar√©_prevista'], mode='lines', 
                             name='Mar√© Prevista', line=dict(color='red'),visible='legendonly'))

    # Atualizar layout
    fig.update_layout(
        title="S√©rie Temporal de Mar√©",
        # xaxis_title='GMT-03:00',
        yaxis_title="Altura da Mar√© (m)",
        legend_title="Tipos de Mar√©",
        showlegend=True,  # Exibir a legenda
        xaxis=dict(
            rangeslider=dict(visible=False),  # Ativar o slider
            type='date'  # Usar formato de data para o eixo X
        )
    )

    # Exibir o gr√°fico no Streamlit
    st.plotly_chart(fig, use_container_width=True)


def exibir_grafico_velocidade_vento(df):
    st.subheader("Gr√°fico de Velocidade do Vento e Rajada")
    


    # Criar gr√°fico de barras sobrepostas
    fig = go.Figure()
    # Adicionar barras para a rajada
    fig.add_trace(go.Bar(x=df['GMT-03:00'], y=df['Gust Speed(m/s)'], name='Rajada',
                         marker=dict(color='orange', opacity=1)))
    # Adicionar barras para a velocidade do vento
    fig.add_trace(go.Bar(x=df['GMT-03:00'], y=df['Wind Speed(m/s)'], name='Velocidade do Vento', 
                         marker=dict(color='yellow', opacity=1)))

    intervalo_6h = df[df['GMT-03:00'].dt.minute == 0].iloc[::6]  # Seleciona a cada 6 horas (em minutos)

    for i in intervalo_6h.index:
        direcao_vento = grau_para_pontos_cardinais(df['Wind Direction(*)'][i])
        fig.add_annotation(
            x=df['GMT-03:00'][i],
            y=-0.05 * max(df['Wind Speed(m/s)'].max(), df['Gust Speed(m/s)'].max()),  # Posiciona abaixo da barra
            text=direcao_vento,
            showarrow=False,
            font=dict(size=10, color="white"),
            align="center"
        )

    # Atualizar layout do gr√°fico
    fig.update_layout(
        barmode='overlay',  # Coloca as barras sobrepostas
        title="Velocidade do Vento e Rajada",
        xaxis_title='GMT-03:00',
        yaxis_title="Velocidade (m/s)",
        showlegend=True,  # Exibir legenda
        xaxis=dict(
            rangeslider=dict(visible=False),  # Desativa o range slider se n√£o necess√°rio
            type='date'  # Formato de data para o eixo X
        )
    )

    # Exibir o gr√°fico no Streamlit
    st.plotly_chart(fig, use_container_width=True)

# Fun√ß√£o para exibir a tabela
def exibir_tabela(df):
    """Exibe a tabela com os dados e inclui op√ß√£o para download."""
    st.subheader("Tabela de Dados")
    
    # Filtros de data
    st.sidebar.subheader("Filtrar por Per√≠odo")
    data_inicio = st.sidebar.date_input("Data Inicial", df['GMT-03:00'].min().date())
    data_fim = st.sidebar.date_input("Data Final", df['GMT-03:00'].max().date())

    if data_inicio > data_fim:
        st.error("A data inicial n√£o pode ser posterior √† data final.")
        return

    # Filtrar dados com base no per√≠odo selecionado
    df_filtrado = df[(df['GMT-03:00'].dt.date >= data_inicio) & (df['GMT-03:00'].dt.date <= data_fim)]
    
    # Verificar permiss√£o do usu√°rio
    if st.session_state.permissao != "admin":
        # Remover colunas terminadas em "flag" para usu√°rios comuns
        df_filtrado = df_filtrado[[col for col in df_filtrado.columns if not col.endswith("flag")]]
    
    # Exibir tabela
    st.dataframe(df_filtrado)

    # Bot√£o para download dos dados filtrados
    csv = df_filtrado.to_csv(index=False)
    st.download_button(
        label="Baixar Dados",
        data=csv,
        file_name="dados_mare_filtrados.csv",
        mime="text/csv"
    )
# Fun√ß√£o principal
menu = criar_menu()

# Exibi√ß√£o de p√°ginas com base no menu selecionado
if menu == "In√≠cio":
    exibir_inicio()
elif menu == "Sobre":
    exibir_sobre()
elif menu == "Cases":
    exibir_cases()
elif menu == "Servi√ßos":
    exibir_servicos()
elif menu == "Produtos":
    exibir_produtos()
elif menu == "Contato":
    exibir_contato()
elif menu == "Login":
    exibir_login()


